%--------------------------------------------------------------------------
% NOTE: This example shows how to define a nonlinear programming problem,
% where all derivative information is automatically generated by
% using the AD tool CasADi.
% 
% You may want to directly pass C functions to FORCES, for example when you 
% are using other AD tools, or have custom C functions for derivate 
% evaluation etc. See the example file "NLPexample_ownFevals.m" for how to
% pass custom C functions to FORCES.
%--------------------------------------------------------------------------
%
% This example solves an optimization problem for a quadcopter
% with the following continuous-time, nonlinear dynamics
%
%    dp/dt      = v
%    dq/dt      = (1/2)*E'*Omega
%    dv/dt      = (1/m)*R*F-g
%    dOmega/dt  = J\(T+Omega)
%
% where (p,v) are the quadcopters position and velocity, 
% and q is its orientation in quarternion representation, and Omega its
% angular velocity.
% (J,m) are the vehicle's inertia matrix and mass.
% The angular velocities of the propellers (w) are the inputs to the
% system, and enter the dynamics via
%
%   F = sum_(k=1:4) (1/2)*rho*A*CL*wk^2
%   T = sum_(k=1:4) ((-1)^k/2)*rho*A*CD*wk^2
%
% where rho is the air density, (CD,CL) are the drag and lift coefficients
% and A is the area of the propellers
%
% The quadcopter must ....
%
% There are bounds on all variables.
%
% Variables are collected stage-wise into z = [w1 w2 w3 w4 p v q Omega].
%
% See also FORCES_NLP
%
% (c) embotech GmbH, Zurich, Switzerland, 2013-16.

clear all; 
close all;
clc;

GENERATE = 0;

%% Problem dimensions
model.N     = 31;   % horizon length
model.nvar  = 21;   % number of variables
model.neq   = 17;   % number of equality constraints
model.nh    = 0;    % number of inequality constraint functions
model.npar  = 8;    % parameters
nx = 17;
nu = 4;
Tf = 1;

timing_iters = 10;

Tsim = 8;
Ns = Tsim/(Tf/(model.N-1));   % simulation length?

% w_pos = 100; w_vel = 0.10; w_att = 100; w_omega = 0.10; w_in = 0.01; w_rate = 0.01; cost_scaling = 1; 
w_pos = 50; w_vel = 5.0; w_att = 20.00; w_omega = 5.0; w_in = 0.01; w_rate = 0.01; cost_scaling = 1; 

%% Objective function
% model.objective = @(z,p)  100*z(5)^2 + 100*z(6)^2 + 100*z(7)^2 + 0.10*z(8)^2  + ...
%                         0.1*z(9)^2 + 0.1*z(10)^2 + 100*(1 - z(11))^2 + 100*z(12)^2 + ...
%                         100*z(13)^2 + 100*z(14)^2 +  0.1*z(15)^2 + 0.1*z(16)^2 + ...
%                         0.1*z(17)^2 + 0.1*z(18)^2 + 0.1*z(19)^2 + 0.1*z(20)^2 + 0.1*z(21)^2 + ... %++ need to fix reference
%                         0.1*(z(1) - p(1))^2 + 0.1*(z(2) - p(1))^2 + 0.1*(z(3)-p(1))^2 + 0.1*(z(4) - p(1))^2;
%                     
% model.objectiveN = @(z,p)  100*z(5)^2 + 100*z(6)^2 + 100*z(7)^2 + 0.10*z(8)^2  + ...
%                         0.1*z(9)^2 + 0.1*z(10)^2 + 100*(1 - z(11))^2 + 100*z(12)^2 + ...
%                         100*z(13)^2 + 100*z(14)^2 +  0.1*z(15)^2 + 0.1*z(16)^2 + ...
%                         0.1*z(17)^2 + 0.1*z(18)^2 + 0.1*z(19)^2 + 0.1*z(20)^2 + 0.1*z(21)^2;

omega_ref = 39.939; % reference

model.objective = @(z,p)    p(8)*(p(1)*z(5)^2 + p(1)*z(6)^2 + p(1)*z(7)^2 + ...
                            p(2)*z(8)^2  + p(2)*z(9)^2 + p(2)*z(10)^2 + ...
                            p(3)*(1 - z(11))^2 + p(3)*z(12)^2 + p(3)*z(13)^2 + p(3)*z(14)^2 +  ...
                            p(4)*z(15)^2 + p(4)*z(16)^2 + p(4)*z(17)^2 + ...
                            p(5)*(z(18)^2-p(7)) + p(5)*(z(19)-p(7))^2 + p(5)*(z(20)^2-p(7)) + p(5)*(z(21)-p(7))^2 + ... %++ need to fix reference
                            p(6)*z(1)^2 + p(6)*z(3)^2 + p(6)*z(3)^2 + p(6)*z(4)^2);
                    
model.objectiveN = @(z,p)   p(1)*z(5)^2 + p(1)*z(6)^2 + p(1)*z(7)^2 + ...
                            p(2)*z(8)^2  + p(2)*z(9)^2 + p(2)*z(10)^2 + ...
                            p(3)*(1 - z(11))^2 + p(3)*z(12)^2 + p(3)*z(13)^2 + p(3)*z(14)^2 +  ...
                            p(4)*z(15)^2 + p(4)*z(16)^2 + p(4)*z(17)^2 + ...
                            p(5)*(z(18)-p(7))^2 + p(5)*(z(19)-p(7))^2 + p(5)*(z(20)-p(7))^2 + p(5)*(z(21)-p(7))^2;
                           
                    
%% Dynamics, i.e. equality constraints 

% We use an explicit RK4 integrator here to discretize continuous dynamics
integrator_stepsize = Tf/(model.N-1);
continuous_dynamics = @(x,u) dynamics(x,u);
model.eq = @(z) RK4( z(5:21), z(1:4), continuous_dynamics, integrator_stepsize, [], 1 );

% Indices on LHS of dynamical constraint - for efficiency reasons, make
% sure the matrix E has structure [0 I] where I is the identity matrix.
model.E = [zeros(17,4), eye(17)];

%% Inequality constraints
% upper/lower variable bounds lb <= x <= ub
%               inputs          |                states
%            w1   w2   w3   w4         p                v               q               Omega
% model.lb = [ 20,  20,  20,  20,  -100*ones(1,3),  -100*ones(1,3),  -100*ones(1,4),  -100*ones(1,3)  ];
% model.ub = [ 60,  60,  60,  60,   100*ones(1,3),   100*ones(1,3),   100*ones(1,4),   100*ones(1,3)  ];
 
max_rate = 40;
% model.lb = [ -max_rate*ones(1,4),  -100, -100, -100,  -100*ones(1,3),  -100*ones(1,4),  ...
%     -max_rate*ones(1,3), -20*ones(1,4)  ];
% model.ub = [ max_rate*ones(1,4),   100*ones(1,3),   100*ones(1,3),   100*ones(1,4),  ...
%     max_rate*ones(1,3),  50*ones(1,4)  ];

model.lb = [ -max_rate*ones(1,4),  -10*ones(1,3),  -100*ones(1,3),  -5*ones(1,4),  ...
    -40*ones(1,3), -20*ones(1,4)  ];
model.ub = [ max_rate*ones(1,4),   10*ones(1,3),   100*ones(1,3),   5*ones(1,4),  ...
    40*ones(1,3),  50*ones(1,4)  ];

%% Initial and final conditions
% initial state
initial_angle_rad = 3;
model.xinit = [0.0 0.0 0.0, 0.0 0.0 0.0, cos(initial_angle_rad/2) ...
    sin(initial_angle_rad/2) 0.0 0.0, 0.0 0.0 0.0, omega_ref, omega_ref, omega_ref, omega_ref]';

model.xinitidx = 5:21;

%% Define solver options
codeoptions = getOptions('FORCESNLPsolver');
codeoptions.maxit = 300;    % Maximum number of iterations
codeoptions.printlevel = 0; % Use printlevel = 2 to print progress (but not for timings)
codeoptions.optlevel = 2;   % 0: no optimization, 1: optimize for size, 2: optimize for speed, 3: optimize for size & speed
codeoptions.nlp.BarrStrat = 'loqo';
codeoptions.BuildSimulinkBlock = 0;
% codeoptions.nlp.linear_solver = 'symm_indefinite';
codeoptions.server = 'https://forces.embotech.com';
Q = diag([w_pos*ones(3,1); w_vel*ones(3,1); w_att*ones(4,1); w_omega*ones(3,1); w_in*ones(4,1)]);
R = diag(w_rate*ones(4,1));
codeoptions.nlp.bfgs_init = diag ([diag(R);  diag(Q)]);
% codeoptions.nlp.max_update_skip = 20;

%% Generate forces solver
if GENERATE
    FORCES_NLP(model, codeoptions);
end
%% Call solver
% Set initial guess to start solver from:
x0i=model.lb+(model.ub-model.lb)/2;
x0=repmat(x0i',model.N,1);
% x0_init = [0.0 0.0 0.0, 0.0 0.0 0.0, cos(initial_angle_rad/2) ...
%     sin(initial_angle_rad/2) 0.0 1, 0.0 0.0 0.0, omega_ref, omega_ref, omega_ref, omega_ref];
% x0 = repmat([zeros(4,1); x0_init.'], model.N, 1 );
problem.x0=x0; 

X = zeros(nx,Ns); X(:,1) = model.xinit;
U = zeros(nu,Ns);
ITER = zeros(1,Ns);
SOLVETIME = zeros(1,Ns);
FEVALSTIME = zeros(1,Ns);

% Cost


xref = [0.0, 0.0, 0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0, 0.0, 0.0, 0.0, 0.0]';
uref = [omega_ref,omega_ref,omega_ref,omega_ref]';
cost = zeros(Ns,1);
ode45_intermediate_steps = 10;
cost_integration_grid = linspace(0,integrator_stepsize,ode45_intermediate_steps);
cost_integration_step_size = integrator_stepsize/ode45_intermediate_steps;

for i=1:Ns
    % Set initial condition
    problem.xinit = X(:,i);

    % Set reference
    problem.all_parameters = repmat([w_pos; w_vel; w_att; w_omega; w_in; w_rate; omega_ref; cost_scaling],model.N,1,1);
    
%     x0 = repmat([zeros(4,1); X(:,i)], model.N, 1 );
%     problem.x0=x0; 
    % Time to solve the NLP!
    min_time = Inf;
    for j = 1:timing_iters
        [output,exitflag,info] = FORCESNLPsolver(problem);
        if info.solvetime < min_time
            min_time = info.solvetime;
        end
    end
    assert(exitflag == 1,'Some problem in FORCES solver');
    U(:,i) = output.x01(1:nu);
    ITER(i) = info.it;
    SOLVETIME(i) = min_time;
    FEVALSTIME(i) = info.fevalstime;
    
    display([ 'sim: ' num2str(i) '   solver iterations:' num2str(ITER(i))])
    
    % Simulate dynamics
    [~,xtemp] = ode45( @(time, states) dynamics(states,U(:,i)), cost_integration_grid, X(:,i) );
    
    % Compute cost
    for j = 1:size(xtemp,1)
        cost(i) = cost(i) + cost_integration_step_size*((xtemp(j,:)' - xref)'*Q*(xtemp(j,:)' - xref) + (U(:,i) - uref)'*R*(U(:,i) - uref));
    end
    X(:,i+1) = xtemp(end,:);
end 

eul_angles = zeros(3,Ns-model.N);
for i=1:Ns
    eul_angles(:,i) = myquat2eul(X(7:10,i));
end

%% Plot results
h1 = figure(1);

subplot(6,2,[1 2]); grid on; hold on;
plot([0:Ns-1]*integrator_stepsize,X(1:3,1:Ns)');
% ylim([-5,0.2]);
legend('x','y','z')
ylabel('position [m]')

subplot(6,2,[3 4]); grid on; hold on;
plot([0:Ns-1]*integrator_stepsize,eul_angles(:,1:Ns)');
legend('roll','pitch','yaw')
ylabel('Euler angles [rad]')
xlabel('time [s]')

subplot(6,2,5);  grid on; hold on;
ylim([17,63]); stairs([0:Ns-1]*integrator_stepsize,X(14,1:Ns)');
legend('\omega_1')
plot([0 Ns-1]*integrator_stepsize, [20 20]', 'r--'); plot([0 Ns-1]*integrator_stepsize, [60 60]', 'r--');


subplot(6,2,6);  grid on; hold on;
ylim([17,63]); stairs([0:Ns-1]*integrator_stepsize,X(15,1:Ns)');
legend('\omega_2')
plot([0 Ns-1]*integrator_stepsize, [20 20]', 'r--'); plot([0 Ns-1]*integrator_stepsize, [60 60]', 'r--');


subplot(6,2,7);  grid on; hold on;
ylim([17,63]); stairs([0:Ns-1]*integrator_stepsize,X(16,1:Ns)');
legend('\omega_3')
xlabel('time [s]')
plot([0 Ns-1]*integrator_stepsize, [20 20]', 'r--'); plot([0 Ns-1]*integrator_stepsize, [60 60]', 'r--');

subplot(6,2,8);  grid on; hold on;
ylim([17,63]); stairs([0:Ns-1]*integrator_stepsize,X(17,1:Ns)');
legend('\omega_1')
plot([0 Ns-1]*integrator_stepsize, [20 20]', 'r--'); plot([0 Ns-1]*integrator_stepsize, [60 60]', 'r--');


subplot(6,2,9);  grid on; hold on;
stairs([0:Ns-1]*integrator_stepsize,U(1,1:Ns)');
legend('\omega_2')
% plot([0 Ns-1]*integrator_stepsize, [20 20]', 'r--'); plot([0 Ns-1]*integrator_stepsize, [60 60]', 'r--');


subplot(6,2,10);  grid on; hold on;
stairs([0:Ns-1]*integrator_stepsize,U(2,1:Ns)');
legend('\omega_3')
xlabel('time [s]')
% plot([0 Ns-1]*integrator_stepsize, [20 20]', 'r--'); plot([0 Ns-1]*integrator_stepsize, [60 60]', 'r--');

subplot(6,2,11);  grid on; hold on;
stairs([0:Ns-1]*integrator_stepsize,U(3,1:Ns)');
legend('\omega_3')
xlabel('time [s]')
% plot([0 Ns-1]*integrator_stepsize, [20 20]', 'r--'); plot([0 Ns-1]*integrator_stepsize, [60 60]', 'r--');

subplot(6,2,12);  grid on; hold on;
stairs([0:Ns-1]*integrator_stepsize,U(4,1:Ns)');
legend('\omega_3')
xlabel('time [s]')
% plot([0 Ns-1]*integrator_stepsize, [20 20]', 'r--'); plot([0 Ns-1]*integrator_stepsize, [60 60]', 'r--');

% savefig('../plots/quadcopter_forces_sim.fig')

h2 = figure(); 
subplot(2,1,1); grid on; hold on;
plot([0:Ns-1]*integrator_stepsize,ITER);
ylabel('iterations')
xlabel('time [s]')
subplot(2,1,2); grid on; hold on;
semilogy([0:Ns-1]*integrator_stepsize,SOLVETIME);
% hold on
% semilogy([0:Ns-1]*integrator_stepsize,FEVALSTIME);
ylabel('CPU time [s]')
xlabel('time [s]')

% savefig(h2,'../plots/quadcopter_forces_stat.fig')

% Compute and plot closed loop cost
% h3= figure();
% grid on;
% plot(cost);
% xlabel('time [s]')
% ylabel('cost')

sum(cost)
% savefig(h3,'../plots/quadcopter_forces_cost.fig')